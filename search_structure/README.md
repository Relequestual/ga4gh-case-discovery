## Search Request

This document describes a search request

Ideas/inspiration _"stolen"_ from [@Relequestual's](https://github.com/Relequestual) [GA4GH Search API Proposal - Components](https://gist.github.com/Relequestual/65c0446944519a66f8562d02b3cb4c86)  and [@Buske's](https://github.com/Buske) [mockup of MME v2](https://github.com/ga4gh/mme-apis/blob/version2-mock/version2/overview.md).


### Structure

`HTTP POST` request to `<base_remote_url>/search`, with an `application/json` body with the following format:

* Questions:
  * Need to reconcile this with version number in the URL


### Specification for search request at a high level.

```
{
    "meta": {
        "request": {
            "components": {
                "queryIdentification": "1.0.0",
                "disclaimer": "1.0.0",
                "patientDescription": "1.0.0",
                "submitter": "1.0.0",
                "contact": "1.0.0",
                "search": "1.0.0",
                "-and": "1.0.0",
                "-or": "1.0.0"
            }
        }
    },

    "requires": {
        "response": {
            "components": [{
                "exists": "^1",
                "counts": "^1",
                "records": {
                    "type": "mme",
                    "version": "^1"
                }
            }]
        }
    },

    "components": {

        "queryIdentification" : {
            "queryID" : "< unique ID generated by the querier >",
            "queryLabel" : "< human readable description >"
        },

        "disclaimer" : {
            "text": "< disclaimer text >",
            "terms" : "< terms text >"
        },

        "patientDescription" : {
            "provenance":{
                "methods":[{
                    "name": "< name of method used to generate this patient data as a string >",
                    "version": "< semantic version of method used to generate data >",
                    "documentation": "< string pointing to github | publication | other >"
                }],
                "data":[{
                    "name": "< name of dataset that was used in this patient data as a string >",
                    "version": "< semantic version of data used >",
                    "institution": "< institution data is hosted on >"
                }]
            },
            "ontology" : " <supported types are: phenoPackets | mme | beacon | fhir >",
            "version" : "< semantic version of ontology >",
            "contentType" : "< content type of ontology, for example: 'Content-Type: application/vnd.ga4gh.matchmaker.v1.0+json'" >",
            "patient": "< description of patient in ontology specified >"
        },

        "submitter": {
            "id" : "< unique ID >",
            "name" : "< first [middle] last >",
            "email" : "< email >",
            "institution" : "< name of institution >",
            "urls" : "< URLs >"
        },

        "contact" : {
            "id" : "< unique ID >",
            "name" : "< first [middle] last >",
            "email" : "< email >",
            "institution" : "< name of institution >",
            "urls" : "< URLs >"
        },

        "search": [
            {
                "componentID": "< unique ID for this component within the scope of this request >",
                "type": "gene",
                "source": "HGNC",
                "id": "FGFR3",
                "description": "< human readable description >"
            },
            {
                "componentID": "< unique ID for this component within the scope of this request >",
                "type": "gene",
                "source": "Ensembl",
                "id": "ENSG00000000",
                "operator": "EQ",
                "description": "< human readable description >"
            },
            {
                "componentID": "< unique ID for this component within the scope of this request >",
                "type": "variant",
                "referenceName": "13",
                "start": 32936732,
                "referenceBases": "G",
                "alternateBases": "C",
                "assemblyId": "GRCh37",
                "description": "< human readable description >"
            },
            {
                "componentID": "< unique ID for this component within the scope of this request >",
                "type": "feature",
                "source": "HPO",
                "id": "HP:0003577",
                "description": "< human readable description >"
            },
            {
                "componentID":" < unique ID for this component within the scope of this request >",
                "type": "alleleFrequency",
                "source": "ExAC",
                "population": "ALL",
                "operator": "LT",
                "value": 0.01,
                "description": "< human readable description >"
            }
        ],

        "-or": [
            {
                "-and": {
                    "componentID": [
                        "< unique ID #1 >,
                        "< unique ID #2 >"
                    ]
                },
                "componentID": "< unique ID #3 >"
            }
        ]
    }
}
```

### Specification for the `meta` structure (required)

* Contains metadata about the request.


### Specification for the `meta`/`request` structure (required)

* Contains the list of components included in the request along with the version number of each of these components.

* Having a component listed here does not mean it is required in the `components` section, however a component is required to have a version number if it is present in the `components` section.

* Version numbers will follow [semantic versioning](https://semver.org).

* Questions:
  * Need to reconcile this with version number in the URL, does that have any meaning any more?
  * Version numbers resolve to components, but not the search items in the `search` components, do we need those to be versioned as well? For example:

```
{
    "meta": {
        "request": {
            "components": {
                "search": {
                    "gene": "1.0.0",
                    "type": "1.0.0",
                    "feature": "1.0.0"
                },
            }
        }
    }
}
```

### Specification for the `requires` structure (required)

* Contains any requirements for the search.


### Specification for the `requires`/`response` structure (required)

* Contains the list of components required in the response along with minimal version for each of the components.

* Questions:
  * Do we want scoring?
    * At what level, record, gene, variant, feature?
    * What range to use 0.00-1.00, 1-100, 1-1000?
    * Do we want to mandate use of specific scoring algorithms?
  * Do we want to support asynchronous searches? This would mean:
    * Allowing the `querier` to tell the `host` to run the search asynchronously.
    * Allowing the `host` to tell the `querier` that it decided to run the search asynchronously (or that the search can only be run asynchronously??).
    * In both cases a callback would need to be specified so that the `host` can return the results to the `querier`.
    * There needs to be a clear network path between the `querier` and the `host`.
    * All this would require the use of the `query identification` so that the `querier` can reconcile results with the original request.


### Specification for the `components` structure (required, see `meta`/`request`/`components` above)

* Contains a list of the components for the search.

* Initially supported components will be:
  * exists
  * counts

* The `records` contains the record type requested:
  * phenopackets
  * mme
  * cloud-dos
  * any GA4GH patient data model

* Questions:
  * Do we want to be able to set a limit to the numbers of records returned?
  * Do we want to support offsets in record returns (start and limit)?
  * Do we want to require support for a minimal set of components?
  * Do we want to support multiple record types in a request?
  * What is the process for defining new component/record types?
  * Do we want to support defined sets of components/records for certain communities (MME)?
  * Do we allow _private_ components?
  * Why is `components` an array of objects if there is only one object?


### Specification for the `components`/`queryIdentification` structure (required)

* Contains the query identification (required) and query label (optional) for the search.

* The query identification is a unique identifier generated by the querier.

* Questions:
  * See question about asynchronous searches in `requires`/`response` above.
  * Do we want to constrain the format of the query identifier (length, characters allowed, integer, uuid)?


### Specification for the `components`/`disclaimer` structure (optional)

* The legal disclaimers and terms of use.

* Questions:
  * Do we want to mandate how these are handled by the `host` and the `querier`?
  * The motivation for the above question is to define the boundary between protocol and policy?


### Specification for the `components`/`patientDescription` structure (optional)

* This is an optional section to support usage in networks such as the Matchmaker Exchange that require a backing patient to be offered with the query.

* `provenance` is an optional section that is in-place to support the documentation of `methods` and `data` that were used to generate the patient data that is being offered.

* The structure used to describe the patient can be of multiple multiple ontologies or networks such as MME, Beacon, and extensible to others as needed.

* Questions:
  * This needs work.


### Specification for the `components`/`submitter` structure (optional)

* The submitter for this search.

* Questions:
  * This feels very Matchmaker Exchange centric, and could be folded into `patientDescription`.


### Specification for the `components`/`contact` structure  (optional)

* The contact for this search if different from the submitter.

* Questions:
  * This feels very Matchmaker Exchange centric, and could be folded into `patientDescription`.


### Specification for the `components`/`search` structure (required)

* The search components for this search.

* Each search component will have a unique component ID (unique within the scope of this search request).

* Each search component will have a type which determines what other fields are present. The search component illustrate a sample of components and it not meant to be exhausting.

* Initially supported components will be:
  * gene
  * annotation
  * alleleFrequency
  * consequence
  * deleteriousnessPrediction
  * variant
  * zygosity
  * transcript
  * inheritanceMode
  * feature

* Questions:
  * Each search component needs to be specified (I think Orion Buske has some good information for that)
  * Do we want to require support for a minimal list of search components?
  * What is the process for adding search components?
  * Do we want to support defined sets search components for certain communities (MME)?
  * Do we allow custom search components?
  * Version numbering as defined above does not resolve to the search components, see above?
  * `Operator` needs to be defined, eg. EQ, NEQ, LT, LTE, GT, GTE.
  * Need to figure out `sources` vs. `id` and CURIEs (I think Chris Mungall was maintaining a list of CURIEs) ?
  * There is plenty of good stuff to _steal_ from [@Buske's](https://github.com/Buske) [mockup of MME v2](https://github.com/ga4gh/mme-apis/blob/version2-mock/version2/overview.md)..


### Specification for the `-or`/`-and` structure (optional)

* The section specifies how the search components are combined as a boolean search.

* Questions:
  * Is this required if specified, ie if the `host` cannot handle boolean searches?


